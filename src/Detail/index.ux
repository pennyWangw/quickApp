<template>
    <!-- template里只能有一个根节点 -->
    <div class="demo-page">
        <div class="top-title">
            <picker type="date" value="{{startDay}}" selected="{{startDay}}" end="{{endDay}}" class="picker" onchange="chooseTime"></picker>
            <text class="arrow">></text>
            <text class="margin-left-xx">—</text>
            <picker class="margin-left-xx" type="date" value="{{endDay}}" start="{{startDay}}" end="{{$app.$def.dateFormat(new Date())}}" selected="{{endDay}}" class="picker"
                    onchange="chooseEndTime"></picker>
            <text class="arrow">></text>
        </div>
        <div class="content-page">
            <block for="(index, content) in dataContent">
                <canvas class="new_canvas" id="{{'newCanvas' + index}}"></canvas>
            </block>
            <!--<text>{{dataContent}}</text>-->
        </div>
    </div>
</template>

<style>
    .demo-page {
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }

    .top-title {
        position: fixed;
        left: 0;
        top: 0;
        font-size: 40px;
        text-align: center;
        line-height: 100px;
        height: 100px;
        background: linear-gradient(#FFAEB9, #ffffff);
        color: #2E2E2E;
        width: 100%;
        flex-direction: row;
        justify-content: center;
    }

    .margin-left-xx {
        margin-left: 80px;
    }

    .content-page {
        margin-top: 100px;
        width: 100%;
        padding: 0 15px;
        /*height: 100%;*/
        flex-direction: column;
        overflow: auto;
    }

    .new_canvas {
        width: 100%;
        height: 900px;
        background-color: #ffffff;
    }

    .arrow {
        transform: rotate(90deg);
        color: #8B1A1A;
        margin-left: 5px;
        margin-top: 5px;
        font-size: 35px;
    }
</style>

<script>
  import data from './data.js'
  import storage from '@system.storage'

  export default {
    private: {
      startDay: '2018-09-28',
      endDay: '2018-10-28',
      dataContent: [],
      allData: [],
      drawComplete: false,
      sectionLen: 20,
      storageData: [],
      startIndex: 0,
      endIndex: 0
    },
    getChooseDayStor() {
      storage.get({
        key: 'penny.chooseDay',
        success: (data) => {
          if (data) this.storageData = JSON.parse(data)
          let len = this.storageData.length
          this.endIndex = len
          if (len > this.sectionLen * 2) {
            this.startIndex = len - this.sectionLen * 2
            this.allData = this.storageData.slice(this.startIndex, this.endIndex)
          } else {
            this.startIndex = 0
            this.endIndex = len
            this.allData = this.storageData
          }
          if (this.allData[0]) {
            this.startDay = this.allData[0].day
            this.endDay = this.allData[this.allData.length - 1].day
          } else {
            this.endDay = this.$app.$def.dateFormat(new Date())
          }
          this.initDataContent(this.allData)
        },
        fail: (data, code) => {
          this.allData = []
        }
      })
    },
    initDataContent(allData) {
      this.dataContent = []
      for(let i=0,len=allData.length;i<len;i+=this.sectionLen){
        this.dataContent.push(allData.slice(i,i+this.sectionLen));
      }
    },
    chooseTime(val) {
      this.startDay = (val.year + '-' + (val.month + 1 < 10 ? ('0' + (val.month + 1)) : val.month + 1) + '-' + (val.day < 10 ? ('0' + val.day) : val.day))
      if (this.allData.length > 0) {
        let startTime = new Date(this.startDay).getTime()
        this.allData.some((item, index) => {
          let curTime = new Date(item.day).getTime()
          let back = startTime < curTime || startTime === curTime
          if (back) {
            this.startIndex = index
            this.anotherDraw()
            this.anotherDraw()
          }
          return back
        })
      }
    },
    chooseEndTime(val) {
      this.endDay = (val.year + '-' + (val.month + 1 < 10 ? ('0' + (val.month + 1)) : val.month + 1) + '-' + (val.day < 10 ? ('0' + val.day) : val.day))
      if (this.allData.length > 0) {
        let endTime = new Date(this.endDay).getTime()
        let lastTime = new Date(this.allData[this.allData.length - 1].day).getTime()
        if (endTime > lastTime) {
          this.endIndex =  this.allData.length
          this.anotherDraw()
        } else {
          this.allData.some((item, index) => {
            let curTime = new Date(item.day).getTime()
            let back = endTime < curTime || endTime === curTime
            if (back) {
              this.endIndex =  index + 1
              this.anotherDraw()
              this.anotherDraw()
            }
            return back
          })
        }
      }
    },
    onShow() {
      this.dataDrawCanvas()
    },
    dataDrawCanvas () {
      if (!this.drawComplete) {
        this.dataContent.forEach((content, index) => {
          this.drawCanvas(content, index);
        })
      }
    },
    anotherDraw () {
      this.initDataContent(this.allData.slice(this.startIndex, this.endIndex))
      this.drawComplete = false
      this.dataDrawCanvas()
    },
    drawCanvas(content, condex) {
      const canvas = this.$element(('newCanvas' + condex)); //获取 canvas 组件
      const ctx = canvas.getContext('2d'); //获取 canvas 绘图上下文
      ctx.clearRect(0,0,1000,1000);
      ctx.beginPath();

      let initX = 50
      let initY = 100
      let endX = 720
      let endY = 620
      // 画外框
      ctx.lineJoin = 'miter'
      ctx.moveTo(initX, initY);
      ctx.lineTo(initX, endY);
      ctx.moveTo(initX, endY);
      ctx.lineTo(endX, endY);
      ctx.closePath();
      ctx.stroke();
      // 表头年月日
      ctx.font = '21px';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'bottom';
      ctx.fillStyle = '#3D3D3D';
      ctx.fillText("年:", 0, 30);
      ctx.fillText("月:", 0, 68);
      ctx.fillText("日:", 0, 97);
      let initDay = content[0].day.split('-')
      ctx.fillText(initDay[0], 54, 35);
      ctx.fillText(initDay[1], 54, 65);

      // 画里面的横线
      let n = (endY - initY) / 13
      ctx.beginPath();
      for (let i = 0; i < 13; i++) {
        let text = parseFloat(36.0 + 0.1 * i).toFixed(1)
        let y = endY - n * i
        ctx.fillText(text, 0, y);
        if (i !== 0) {
          ctx.moveTo(initX + 1, y);
          ctx.lineTo(endX, y);
        }
      }
      ctx.strokeStyle = '#eaeaea';
      ctx.stroke();
      ctx.closePath();

      // 里面的竖线
      let xN = (endX - initX) / (this.sectionLen + 1)
      ctx.beginPath();
      for (let i = 0; i < this.sectionLen; i++) {
        let x = initX + xN * i + xN
        ctx.moveTo(x, initY);
        ctx.lineTo(x, endY - 1);
      }
      ctx.strokeStyle = '#eaeaea';
      ctx.stroke();
      ctx.closePath();

      // 根据数据画折线
      // ctx.beginPath();
      let lastX
      let lastY
      content.forEach((item, index) => {
        let charInitY = endY + 20 //备注信息初始Y坐标位置
        ctx.fillStyle = '#3D3D3D';
        let y
        let x = initX + xN * index + 1 / 2 * xN

        if (item.tempValue && item.tempValue > 35.99 && item.tempValue < 37.21) {
          y = endY - (item.tempValue - 36) / 0.1 * n
          // 折线
          ctx.beginPath();
          if (lastY) {
            if (this.getDays(item.day, content[index-1].day) > 1) {
              ctx.moveTo(x, y);
            } else {
              ctx.moveTo(lastX, lastY);
            }

          } else {
            ctx.moveTo(x, y);
          }
          ctx.lineTo(x, y);
          ctx.strokeStyle = '#8B5742';
          ctx.stroke();
          ctx.closePath();
          // 画圆点，代表是否有性生活
          ctx.arc(x, y, 4, 0, 360, true)
          ctx.fill()
          ctx.closePath();
          ctx.beginPath();
          if (item.sexLife) {
            ctx.arc(x, y, 8, 0, 370, true)
            if (item.sexTime !== '请选择时间') {
              ctx.font = '12px';
              ctx.fillText(item.sexTime, x - 14, charInitY);
              charInitY += 16
            }
          }
          ctx.stroke()
        } else {
          ctx.font = '12px';
          if (item.tempValue && (item.tempValue < 36 || item.tempValue > 37.2)) {
            ctx.fillText(item.tempValue, x - 12, charInitY);
            charInitY += 12
          }
          if (item.sexLife) {
            ctx.strokeStyle = '#8B5742';
            ctx.beginPath();
            // 画圆点，代表是否有性生活
            ctx.arc(x, charInitY, 4, 0, 360, true)
            ctx.fill()
            ctx.closePath();
            ctx.arc(x, charInitY, 8, 0, 360, true)
            ctx.stroke()
            charInitY += 25
            if (item.sexTime !== '请选择时间') {
              ctx.fillText(item.sexTime, x - 14, charInitY);
              charInitY += 14
            }
          }
        }

        // 表头年月日显示
        let day = item.day.split('-')
        ctx.font = '14px';
        if (index !== 0) { // 日
          ctx.fillText(day[2], x - 6, 95);
        } else {
          ctx.fillText(day[2], x - 6, 91);
        }
        if (lastX) {
          let lastDay = content[index - 1].day.split('-')
          if (lastDay[1] !== day[1]) {
            ctx.font = '21px';
            ctx.fillText(day[1], x - 12, 65); // 月
          }
          if (day[0] !== lastDay[0]) {
            ctx.fillText(day[0], x - 12, 35); // 年
          }
        }
        // 备注信息显示
        ctx.font = '14px';

        for (let j = 0; j < item.otherText.length; j++) {
          let char = item.otherText[j]
          ctx.fillText(char, x - 8, charInitY + j*14);
        }

        // 月经信息显示
        ctx.font = '20px';
        ctx.fillStyle = '#8B2500';
        if (item.isPeriod) {
          let pY = initY + n/2 + 10
          if (item.periodNum === '量少') {
            ctx.font = '30px';
            ctx.fillText('、', x - 6, pY);
          } else if(item.periodNum === '量多') {
            ctx.fillText('x', x - 6, pY - 7);
            ctx.fillText('x', x - 6, pY + 7);
          } else {
            ctx.fillText('x', x - 6, pY);
          }
        }
        lastX = x
        lastY = y
      })
      ctx.closePath();
      if (condex === this.dataContent.length - 1) {
        this.drawComplete = true;
      }
      //
    },
    getDays(strDateStart, strDateEnd){
      let iDays;
      let strDateS = new Date(strDateStart);
      let strDateE = new Date(strDateEnd);
      iDays = parseInt(Math.abs(strDateS - strDateE ) / 1000 / 60 / 60 /24)//把相差的毫秒数转换为天数
      return iDays ;
    },
    onMenuPress() {
      this.$app.$def.showMenu()
    },
    onInit() {
      this.getChooseDayStor()
      // this.dataContent = data
    }
  }
</script>
